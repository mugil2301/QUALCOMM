#!/bin/bash

g=(1000 1000 1000)						# g(s) for all nodes are set to infinte 

rhs=(1000 1000 0)						# rhs(s) of all except goal is set infinte and rhs(goal) = 0
open=(-1 -1 -1)							# open list is empty 
declare -A key
num_rows=3
num_columns=2
h=(0 1 1)                               			# heuristics calculated based on the no of hops from start node

declare -A adj							#adjcency matrix has to path cost and need to be updated if cost changes 
num_rows=3
num_columns=3

adj[0,0]=0
adj[0,1]=10
adj[0,2]=25
adj[1,0]=1000
adj[1,1]=0
adj[1,2]=20
adj[2,0]=1000
adj[2,1]=1000
adj[2,2]=0

visited=(-1 -1 -1)

declare -i start=0                                		#start node; in our case its node '0'
declare -i goal=2 						# goal node; in our case its node '2'
			
declare -A sucs							# successors of each node
num_rows=3
num_columns=2
sucs[0,0]=1
sucs[0,1]=2
sucs[1,0]=2
sucs[1,1]=-1
sucs[2,0]=-1
sucs[2,1]=-1

declare -A pred							# predecessors of each node 
num_rows=3
num_columns=2
pred[0,0]=-1
pred[0,1]=-1
pred[1,0]=0
pred[1,1]=-1
pred[2,0]=0
pred[2,1]=1	

declare -i n=0

next=(-1 -1 -1)						#stores the next hop node of each node; path is extracted from this

cal_key () {	
	
	local i="$0"
	
	while [$i -lt 2 ]
	do
	
		if [ ${g[${i}]} -ge {rhs[${i}]} ]
		then
			key[${i},0]=$(( ${rhs[${i}]} + ${h[${i}]} ))                #calculating key value for each node
			key[${i},1]=${rhs[${i}]}

		else
		
			key[${i},0]= $(( ${g[${i}]} + ${h[${i}]} ))
			key[${i},1]=${g[${i}]}
			
		fi
		i=$(($i+1))
	done
	#visited[${i}]=-1
	return
}



add_visited (){                            #adding a node to visited list.												   // once added to the visited list it need not be removed even added to 
	
	local i=0			   # open list once again.
	
	if [ ${visited[0]} -eq -1 ]
	then
		visited[0] = $$n
	
	else
	
	
		while [ "${visited[${i}]" != -1 ] && [ "$i" -it 2 ]
		do	
			                                       
			i=$(($i+1))
		done
	
		visited[${i}]= "$n"
	fi

	return
}

rem_open () {
	local -i i=0
	while [ $i -lt 3 ]
	do
		if [ "$n" = "${open[${i}]}" ]
		then
			open[${i}] = -1                         # if s in open then remove 
			add_visited "$n"
		else
			i=$(($i+1))
		fi
	done

}

add_open () {	
	local -i i =0
	while ["${open[${i}]}" != -1] && [ "$i" -lt 3 ] && [ "$n" -lt 3 ]               // adding s to open list
	do
		i=$(($i+1))
	done
	
	if ["$n" -lt 3 ]
	then
		open[${i}] = "$n"
	fi
}

min_rhs (){

	local -i i =0
	local -i k=0
	local -i c=0
	local -i min =1500
	for (( i=0; i<2; i++ ))
	do	
		k = ${sucs[${n},${i}]}
		c = ${adj[${n},${k}]}
		c = "$c" + ${g[${k}]}
	
		if [ $min -lt $c ]
		then
			min = "$c"
			
			next[${n}] = "$k"                     #storing the path 
		
		fi
	done
	
	rhs[$n] = "$min"
	
}


update_state (){	
	
	local -i i = 0
	local -i flag = 0
	local -i flag2 = 0
		cal_key 
	
	
	while [ $i -lt 3 ]                           # s not visited
	do
		if [ $n = ${visited[${i}]} ]
		then
			flag = 1;
			break
		else
		
		  i=$(($i+1))
		fi
	done

	if [ $flag = 0 ]
	then
			g[$n] = 1000; 
			 
		                        #  g(s) = infinite
	fi

	
	if [ $n != $goal ]
	then	
		
		min_rhs "$n"                               # rhs = min {c(s,s') + g(s') where s' belongs to succ of s} 
	fi
	i=0
	

	while [ $i -lt 3 ]
	do
		if [ ${open[${i}]} != -1 ] && [ ${open[${i}]} = $n ]
		then
			flag2=1										// if s is in open list  
		fi
		i=$(($i+1))
	done
	if [ "$flag2" = 1 ]
	then
		rem_open "$n"                             # remove s from open list
	fi
	
		
	if [ ${g["$n"]} != ${rhs["$n"]} ]                      # if s is inconsistant i.e. g(s)!=rhs(s) 
	then
		add_open "$n"
		                         # if g(s)!=rhs(s) then add to open list
	fi
	
	
}

min_key (){                                  #finds the minimum key and returns to the check loop function 
												//  for expanding in the shortest path
	local -i min=2
	local -i i=0
	local -i j
	local -i flag =0									
	
	cal_key
	j=-1                                                        
	i=0
	min=-1
	if [ ${open[0]} != -1 ]
	then
		min =0	
		i=1
		
		while [ ${open[${i}]} != -1 ] && [ "$i"-lt 3 ]
		do
			if [ ${key[${open[${i}]},0]} -lt ${key[${open[${min}]},0]} ]
				then
					min="$i"
				
					
					
				
				else if [ ${key[${open[${i}]},1]} -lt ${key[${open[${min}]},1]} ] && [ ${key[${open[${i}]},0]} = ${key[${open[${min}]},0]} ]
				
					min="$i"
				
					
				
				else
					i=$(($i+1))
				fi
		done
	fi
	n=${open["$min"]}
	
			

		
	return "$min"
}

check_loop(){
	local -i i
	local -i j
	local -i min = 0
	
	cal_key
	
	min = min_key
	if [ "$min" = -1 ]
	then
		return "0"
	fi
	

	if [ ${key[${n},0]} -lt ${key[${start},0]} ]
	then
			return "1"
			
	
	else if [ ${key[${n},1]} -lt ${key[${start},1]} ]
	
			return "1"                                           // checking the initial condition to enter shortest path
		
	
	else if [ ${rhs[${start}]} != ${g[${start}]} ]
	
			return "1"
		
	fi
	
	
	return "0"
		
		
		
}

shortest_path (){	

	local -i i = 0
	local -i z
	while [ check_loop() ]
	do	
		rem_open "$n"
		if [ ${g[${n}]} -lt ${rhs[${n}]} ]
		then	
			
			local -i i = 0
			g[${n}]=${rhs[${n}]}
			
			while [ "$i" -lt 2 ] && [ ${pred["${n}","${i}"]} != -1 ]
			do   
			
				update_state "${pred["${n}","${i}"]}"
				i=$(($i+1))          									 // update predecesor of s
			done
			
			cal_key
		
		
		else if [ ${g[${n}]} -lt ${rhs[${n}]} ]                             // update predecesor U {s};  meaning updating s and then its preds
		
			g[${n}]=1000											// g[s] = infinite
			update_state "$n"                             	
			i=0
			while [ "$i" -lt 2 ] && [ ${pred[${n},${i}]} != -1 ]
			do   
				update_state "${pred[${n},${i}]}" 				// updating pred of s
				i=$(($i+1))                                                  
			done
			
		fi
		
	done
}

print_path ()
{	
	local -i i=0
	printf("\nPath is %d ",start);
	for (( i=0; i<2; i++ ))
	do
	
		if [ "${next[${i}]}" != "$goal" ]
		then
			printf("---> %d",next[i]);   
		                                									  // printing path
		else if [ "${next[${i}]}" = "$goal" ]
		
			printf("---> %d\n",next[i]);
			break
		fi
	done
	return	
}
change_cost(){	
	local -i s
	local -i d 
	local -i cost
	printf("\nEnter the source node ---> destination node to update path \n");
	%%scanf("%d %d",&s,&d);
	printf("\n update the cost :");
	%%scanf("%d",&cost);
	adj[${s},${d}]="$cost"                   								//  changing the cost of path
	update_state "$s"
	cal_key
 	shortest_path
	cal_key
	print_path
}

main (){	
	local -i i=0
	
	
	g[2]=1000											// 1000 ~ infinite
	rhs[2]=0													// Initilization
	open[0]=2
	
	cal_key 
	shortest_path 
	cal_key
	print_path                        				#first run

	while [ "$i" -lt 3 ]
	do
		change_cost                             #changing the cost for 3 times as i<3
		i=(($i+1))
	done

	return "0"
		
}
