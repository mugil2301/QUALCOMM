#include <stdio.h>

int g[3]={1000,1000,1000};							// g(s) for all nodes are set to infinte 
int rhs[3]={1000,1000,0};							// rhs(s) of all except goal is set infinte and rhs(goal) = 0
int open[3]= {-1,-1,-1};							// open list is empty 
int key[3][2]; 
int h[3]={0,1,1};                                 // heuristics calculated based on the no of hops from start node

int adj[3][3] = {0,10,25, 1000,0,20, 1000,1000,0};   // adjcency matrix has to path cost and need to be updated if cost changes 
int visited[3]= {-1,-1,-1};
int start = 0;                                     // start node; in our case its node '0'
int goal = 2;									// goal node; in our case its node '2'
int sucs[3][2] = {1,2, 2,-1, -1,-1};				// successors of each node
int pred[3][2] = {-1,-1, 0,-1, 0,1};			// predecessors of each node 
int n = 0;
int next[3] = {-1,-1,-1};						// stores the next hop node of each node; path is extracted from this

void cal_key()
{	
	
	int i=0;
	while(i<3)
	{
	
		if(g[i]>=rhs[i])
		{
			key[i][0]= rhs[i]+h[i];                // calculating key value for each node
			key[i][1]=rhs[i];
		}
		else
		{
			key[i][0]= g[i]+h[i];
			key[i][1]=g[i];
			
		}
		i++;
	}

	return;
}



void add_visited(int n)                            // adding a node to visited list.
{												   // once added to the visited list it need not be removed even added to 
	int i=0;									   // open list once again.
	if(visited[0]==-1)
	{
		visited[0]=n;
	}
	else
	{
	
		while((visited[i]!=-1)&&(i<2))
		{	
			                                       
			i++;
		}
	
		visited[i]= n;
	}

	return;
}

void rem_open(int n)
{
	int i=0;
	while(i<3)
	{
		if(n==open[i])
		{
			open[i] = -1;                         // if s in open then remove 
			add_visited(n);
		}
		else
			i++;
	}

}

void add_open(int n)
{	
	int i =0;
	while((open[i]!=-1)&&i<3&&n<3)               // adding s to open list
	{
		i++;
	}
	
	if(n<3)
	open[i] = n;
	
}

void min_rhs(int n)
{	
	int i=0,k=0,c=0,min =1500;
	for(i=0;i<2;i++)
	{	
		k = sucs[n][i];
		c = adj[n][k];
		c = c+g[k];
	
		if(min>c)
		{
			min = c;
			
			next[n] = k;                     // storing the path 
		
		}
	}
	
	rhs[n] = min;
	
}


void update_state(int n)
{	
	
	int i = 0, flag = 0, flag2 = 0;
		cal_key();
	
	
	while(i<3)                           //  s not visited
	{
		if(n==visited[i])
		{
			flag = 1;
			break;
		}
		
		else
		{
		  i++;
		}
	}

	if(flag==0)
		{
			g[n] = 1000; 
			 
		                        //  g(s) = infinite
		}

	
	if(n!=goal)
	{	
		
		min_rhs(n);                               //  rhs = min {c(s,s') + g(s') where s' belongs to succ of s} 
	}
	i=0;
	

	while(i<3)
	{
		if((open[i]!=-1)&&(open[i]==n))
		{
			flag2 =1;										// if s is in open list  
		}
		i++;
	}
	if(flag2==1)
	{
		rem_open(n);                             // remove s from open list
	}
	
		
	if(g[n]!=rhs[n])                      // if s is inconsistant i.e. g(s)!=rhs(s) 
	{
		add_open(n);
		                         // if g(s)!=rhs(s) then add to open list
	}
	
	
}

int min_key()                                  // finds the minimum key and returns to the check loop function 
{												//  for expanding in the shortest path
	int min=2,i=0,j, flag =0;									
	
	cal_key();
	j =-1;                                                        
	i=0;
	min = -1;
	if(open[0]!=-1)
	{
		min =0;	
		i=1;
		
		while((open[i]!=-1)&&i<3)
		{	
			if(key[open[i]][0]<key[open[min]][0])
				{
					min = i;
				
					
					
				}
				else if((key[open[i]][1]<key[open[min]][1])&&(key[open[i]][0]==key[open[min]][0]))
				{
					min =i;
				
					
				}
				else
					i++;
			
		}
	}
	n = open[min];
	
			

		
	return min;
}

int check_loop()
{
	int i,j, min = 0;
	
	cal_key();
	
	min = min_key();
	if(min==-1)
	{
		return 0;
	}
	

	if(key[n][0]<key[start][0])
	{
			return 1;
			
	}
	else if(key[n][1]<key[start][1])
	{
			return 1;                                           // checking the initial condition to enter shortest path
		
	}
	else if(rhs[start]!=g[start])
	{
			return 1;
		
	}
	
	
	return 0;
		
		
		
}

void shortest_path()
{	

	int i = 0, z;
	while(check_loop())
	{	
		rem_open(n);
		if(g[n]>rhs[n])
		{	
			
			i = 0;
			g[n] = rhs[n];
			
			while((i<2)&&(pred[n][i]!=-1))
			{   
			
				update_state(pred[n][i]);
				i++;             									 // update predecesor of s
			}
			
			cal_key();
		
		}
		else if(g[n]<rhs[n])                             // update predecesor U {s};  meaning updating s and then its preds
		{
			g[n] = 1000;											// g[s] = infinite
			update_state(n);                             	
			i=0;
			while((i<2)&&(pred[n][i]!=-1))
			{   
				update_state(pred[n][i]); 				// updating pred of s
				i++;                                                  
			}
			
		}
		
	}
}

void print_path()
{	
	int i=0;
	printf("\nPath is %d ",start);
	for(i=0;i<2;i++)
	{
	
		if(next[i]!=goal)
		{
			printf("---> %d",next[i]);   
		}                                 									  // printing path
		else if(next[i]==goal)
		{
			printf("---> %d\n",next[i]);
			break;
		}
	}
	return;	
}

void change_cost()
{	
	int s,d,cost;
	printf("\nEnter the source node ---> destination node to update path \n");
	scanf("%d %d",&s,&d);
	printf("\n update the cost :");
	scanf("%d",&cost);
	adj[s][d] = cost;                   								//  changing the cost of path
	update_state(s);
	cal_key();
 	shortest_path();
	cal_key();
	print_path();
}

int main(void)
{	
	int i=0;
	
	
	g[2] = 1000;											// 1000 ~ infinite
	rhs[2] = 0;													// Initilization
	open[0] = 2;
	
	cal_key();
	shortest_path();
	cal_key();
	print_path();                         				//  first run

	while(i<3)
	{
		change_cost();                            // changing the cost for 3 times as i<3
		i++;
	}

	return 0;
		
}
